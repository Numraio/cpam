generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  OWNER
  MEMBER
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                     String    @id @default(uuid())
  name                   String
  email                  String    @unique
  emailVerified          DateTime?
  password               String?
  image                  String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @default(now())
  invalid_login_attempts Int       @default(0)
  lockedAt               DateTime?

  teamMembers TeamMember[]
  accounts    Account[]
  sessions    Session[]
  invitations Invitation[]
}

model Team {
  id              String   @id @default(uuid())
  name            String
  slug            String   @unique
  domain          String?  @unique
  defaultRole     Role     @default(MEMBER)
  billingId       String?
  billingProvider String?

  // Usage tracking (cached, updated on item create/delete)
  itemsUnderManagement Int @default(0) // Cached count for performance
  usageLastUpdated     DateTime? // Last time usage was recalculated

  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now())

  // BoxyHQ relations
  members     TeamMember[]
  invitations Invitation[]
  apiKeys     ApiKey[]

  // CPAM relations
  contracts           Contract[]           @relation("ContractTenant")
  items               Item[]               @relation("ItemTenant")
  pams                PAM[]                @relation("PAMTenant")
  indexSeries         IndexSeries[]        @relation("IndexSeriesTenant")
  indexValues         IndexValue[]         @relation("IndexValueTenant")
  calcBatches         CalcBatch[]          @relation("CalcBatchTenant")
  calcResults         CalcResult[]         @relation("CalcResultTenant")
  approvalEvents      ApprovalEvent[]      @relation("ApprovalEventTenant")
  auditLogs           AuditLog[]           @relation("AuditLogTenant")
  proposals           Proposal[]           @relation("ProposalTenant")
  providerCredentials ProviderCredential[] @relation("ProviderCredentialTenant")
  scenarios           Scenario[]           @relation("ScenarioTenant")

  @@index([billingId])
}

model TeamMember {
  id        String   @id @default(uuid())
  teamId    String
  userId    String
  role      Role     @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([userId])
}

model Invitation {
  id             String   @id @default(uuid())
  teamId         String
  email          String?
  role           Role     @default(MEMBER)
  token          String   @unique
  expires        DateTime
  invitedBy      String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now())
  sentViaEmail   Boolean  @default(true)
  allowedDomains String[] @default([])

  user User @relation(fields: [invitedBy], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, email])
  @@index([email])
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  email     String
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime
}

model ApiKey {
  id         String    @id @default(uuid())
  name       String
  teamId     String
  hashedKey  String    @unique
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())
  expiresAt  DateTime?
  lastUsedAt DateTime?

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([teamId])
}

model Subscription {
  id         String    @id
  customerId String
  priceId    String
  active     Boolean   @default(false)
  startDate  DateTime
  endDate    DateTime
  cancelAt   DateTime?

  // Entitlements
  maxItemsUnderManagement Int? // Items under Management (IuM) limit, null = unlimited

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())

  @@index([customerId])
}

model Service {
  id          String   @id @default(uuid())
  description String
  features    String[]
  image       String
  name        String
  created     DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())
  Price       Price[]
}

model Price {
  id            String   @id @default(uuid())
  billingScheme String
  currency      String
  serviceId     String
  amount        Int?
  metadata      Json
  type          String
  created       DateTime

  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model jackson_store {
  key        String    @id(map: "_jackson_store_key") @db.VarChar(1500)
  value      String
  iv         String?   @db.VarChar(64)
  tag        String?   @db.VarChar(64)
  createdAt  DateTime  @default(now()) @db.Timestamp(6)
  modifiedAt DateTime? @db.Timestamp(6)
  namespace  String?   @db.VarChar(256)

  jackson_index jackson_index[]

  @@index([namespace], map: "_jackson_store_namespace")
  @@ignore
}

model jackson_index {
  id       Int    @id(map: "_jackson_index_id") @default(autoincrement())
  key      String @db.VarChar(1500)
  storeKey String @db.VarChar(1500)

  store jackson_store @relation(fields: [storeKey], references: [key], onDelete: Cascade, onUpdate: NoAction)

  @@index([key], map: "_jackson_index_key")
  @@index([key, storeKey], map: "_jackson_index_key_store")
  @@ignore
}

model jackson_ttl {
  key       String @id(map: "jackson_ttl_key") @db.VarChar(1500)
  expiresAt BigInt

  @@index([expiresAt], map: "_jackson_ttl_expires_at")
  @@ignore
}

// ============================================================================
// CPAM Domain Models
// ============================================================================

enum ContractStatus {
  DRAFT
  ACTIVE
  EXPIRED
  TERMINATED
}

enum VersionTag {
  PRELIMINARY
  FINAL
  REVISED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum CalcStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
}

// Tenant model - maps to Team for multi-tenancy
// We use Team.id as tenant_id throughout CPAM models
// This allows BoxyHQ's team management to drive tenant isolation

model Contract {
  id          String         @id @default(uuid())
  tenantId    String // FK to Team.id
  name        String
  description String?        @db.Text
  status      ContractStatus @default(DRAFT)
  startDate   DateTime
  endDate     DateTime?
  createdBy   String // FK to User.id
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  tenant Team   @relation("ContractTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  items  Item[]

  @@index([tenantId])
  @@index([status])
  @@index([tenantId, status])
}

model Item {
  id           String    @id @default(uuid())
  tenantId     String // FK to Team.id
  contractId   String
  sku          String // Product SKU or identifier
  name         String
  description  String?   @db.Text
  basePrice    Decimal   @db.Decimal(20, 12) // 12 decimal places for financial precision
  baseCurrency String    @db.VarChar(3) // ISO 4217 currency code
  uom          String // Unit of measure (kg, lb, MT, etc.)
  pamId        String? // Optional: link to PAM for this item
  fxPolicy     FXPolicy? @default(PERIOD_AVG) // FX rate policy
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  tenant   Team         @relation("ItemTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  contract Contract     @relation(fields: [contractId], references: [id], onDelete: Cascade)
  pam      PAM?         @relation("ItemPAM", fields: [pamId], references: [id], onDelete: SetNull)
  results  CalcResult[]

  @@unique([tenantId, contractId, sku])
  @@index([tenantId])
  @@index([contractId])
  @@index([pamId])
}

model PAM {
  id          String   @id @default(uuid())
  tenantId    String // FK to Team.id
  name        String
  description String?  @db.Text
  version     Int      @default(1)
  graph       Json // Stores PAMGraph structure (nodes, edges, metadata)
  createdBy   String // FK to User.id
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant      Team        @relation("PAMTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  items       Item[]      @relation("ItemPAM")
  calcBatches CalcBatch[]
  scenarios   Scenario[]  @relation("ScenarioPAM")

  @@index([tenantId])
  @@index([tenantId, name])
}

model IndexSeries {
  id          String   @id @default(uuid())
  tenantId    String // FK to Team.id
  seriesCode  String // e.g., "PLATTS_BRENT", "USD_EUR"
  name        String
  description String?  @db.Text
  provider    String // e.g., "PLATTS", "OANDA", "MANUAL"
  dataType    String // "INDEX", "FX", "CUSTOM"
  unit        String? // For indices: "USD/bbl", for FX: currency pair
  frequency   String // "DAILY", "WEEKLY", "MONTHLY"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant Team         @relation("IndexSeriesTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  values IndexValue[]

  @@unique([tenantId, seriesCode])
  @@index([tenantId])
  @@index([provider])
}

model IndexValue {
  id                String     @id @default(uuid())
  tenantId          String // FK to Team.id
  seriesId          String
  asOfDate          DateTime   @db.Date
  value             Decimal    @db.Decimal(20, 12) // 12dp precision
  versionTag        VersionTag @default(PRELIMINARY)
  providerTimestamp DateTime? // When provider published this data
  ingestedAt        DateTime   @default(now())

  // Relations
  tenant Team        @relation("IndexValueTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  series IndexSeries @relation(fields: [seriesId], references: [id], onDelete: Cascade)

  // Composite PK: series + date + version allows prelim/final/revised versions
  @@unique([seriesId, asOfDate, versionTag])
  @@index([tenantId])
  @@index([seriesId, asOfDate])
  @@index([asOfDate])
}

model CalcBatch {
  id          String     @id @default(uuid())
  tenantId    String // FK to Team.id
  pamId       String
  contractId  String? // Optional: calculate for specific contract
  scenarioId  String? // Optional: FK to Scenario.id - if this is a scenario calculation
  inputsHash  String // Hash of inputs for idempotency
  status      CalcStatus @default(QUEUED)
  startedAt   DateTime?
  completedAt DateTime?
  error       String?    @db.Text
  metadata    Json? // Store run parameters, triggered by, etc.
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  tenant                Team         @relation("CalcBatchTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  pam                   PAM          @relation(fields: [pamId], references: [id], onDelete: Cascade)
  scenario              Scenario?    @relation("ScenarioBatches", fields: [scenarioId], references: [id], onDelete: SetNull)
  results               CalcResult[]
  proposalsAsOriginal   Proposal[]   @relation("ProposalOriginalBatch")
  proposalsAsProposal   Proposal[]   @relation("ProposalProposalBatch")

  @@index([tenantId])
  @@index([pamId])
  @@index([scenarioId])
  @@index([status])
  @@index([inputsHash])
}

model CalcResult {
  id               String   @id @default(uuid())
  tenantId         String // FK to Team.id
  batchId          String
  itemId           String
  adjustedPrice    Decimal  @db.Decimal(20, 12)
  adjustedCurrency String   @db.VarChar(3)
  contributions    Json // Waterfall of factor contributions
  effectiveDate    DateTime @db.Date
  createdAt        DateTime @default(now())

  // Approval fields
  isApproved  Boolean   @default(false)
  approvedBy  String? // FK to User.id
  approvedAt  DateTime?

  // Override fields (for manual price adjustments)
  isOverridden             Boolean   @default(false)
  originalCalculatedPrice  Decimal?  @db.Decimal(20, 12) // Preserve original calculation
  overrideReason           String?   @db.Text
  overriddenBy             String? // FK to User.id
  overriddenAt             DateTime?

  // Relations
  tenant Team      @relation("CalcResultTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  batch  CalcBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  item   Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([batchId, itemId, effectiveDate])
  @@index([tenantId])
  @@index([batchId])
  @@index([itemId])
  @@index([isApproved])
  @@index([isOverridden])
}

model ApprovalEvent {
  id         String         @id @default(uuid())
  tenantId   String // FK to Team.id
  entityType String // "CALC_BATCH", "CONTRACT", "PAM"
  entityId   String
  status     ApprovalStatus @default(PENDING)
  approvedBy String? // FK to User.id
  rejectedBy String? // FK to User.id
  comments   String?        @db.Text
  approvedAt DateTime?
  rejectedAt DateTime?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  // Relations
  tenant Team @relation("ApprovalEventTenant", fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([entityType, entityId])
  @@index([status])
}

model AuditLog {
  id            String   @id @default(uuid())
  tenantId      String // FK to Team.id
  userId        String // FK to User.id
  action        String // "CREATE", "UPDATE", "DELETE", "APPROVE", "REJECT", "CALCULATE", "OVERRIDE", "EXPORT", "IMPORT"
  entityType    String // "CONTRACT", "ITEM", "PAM", "CALC_BATCH", "CALC_RESULT", "APPROVAL_EVENT"
  entityId      String
  correlationId String? // Groups related events (e.g., all events in a batch calculation)
  changes       Json? // Store before/after state (PII-masked)
  metadata      Json? // Additional context
  ipAddress     String?
  userAgent     String?  @db.Text
  createdAt     DateTime @default(now())

  // Relations
  tenant Team @relation("AuditLogTenant", fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([entityType, entityId])
  @@index([correlationId])
  @@index([createdAt])
  @@index([tenantId, createdAt])
  @@index([action])
}

enum ProposalStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  REJECTED
}

enum ProposalType {
  CREDIT // Customer owes us money (price went up)
  DEBIT  // We owe customer money (price went down)
}

enum FXPolicy {
  PERIOD_AVG      // Average FX rate over calculation period
  EOP             // End-of-period rate (last business day)
  EFFECTIVE_DATE  // Rate on specific effective date
}

model Proposal {
  id                    String         @id @default(uuid())
  tenantId              String
  originalBatchId       String // FK to CalcBatch.id
  proposalBatchId       String? // FK to CalcBatch.id (recalculation with revised data)
  type                  ProposalType
  status                ProposalStatus @default(DRAFT)
  reason                String         @db.Text // Why was this proposal created? (e.g., "OANDA revised WTI prices for 2024-10-15")
  revisionDescription   String?        @db.Text // Details about what data was revised
  totalDelta            Decimal        @db.Decimal(20, 12) // Sum of all price deltas
  deltaCurrency         String         @db.VarChar(3)
  affectedItemCount     Int // How many items are affected
  affectedItemIds       Json // Array of item IDs affected
  deltas                Json // Array of { itemId, originalPrice, revisedPrice, delta }

  // Approval tracking
  requestedBy           String
  requestedAt           DateTime       @default(now())
  reviewedBy            String?
  reviewedAt            DateTime?
  comments              String?        @db.Text

  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  // Relations
  tenant         Team       @relation("ProposalTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  originalBatch  CalcBatch  @relation("ProposalOriginalBatch", fields: [originalBatchId], references: [id], onDelete: Cascade)
  proposalBatch  CalcBatch? @relation("ProposalProposalBatch", fields: [proposalBatchId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([originalBatchId])
  @@index([proposalBatchId])
  @@index([status])
  @@index([type])
  @@index([requestedAt])
}

model Scenario {
  id          String   @id @default(uuid())
  tenantId    String // FK to Team.id
  name        String
  description String?  @db.Text
  pamId       String // FK to PAM.id - which PAM this scenario is based on
  baselineId  String? // FK to CalcBatch.id - baseline to compare against (optional)

  // Overrides - what inputs are being changed in this scenario
  overrides   Json // { itemOverrides: { itemId: { property: value } }, indexOverrides: { seriesCode: { date: value } } }

  // Published flag - scenarios are never published, but track if results have been approved
  published   Boolean  @default(false) // Always false - scenarios don't affect production

  // Metadata
  createdBy   String // FK to User.id
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant      Team       @relation("ScenarioTenant", fields: [tenantId], references: [id], onDelete: Cascade)
  pam         PAM        @relation("ScenarioPAM", fields: [pamId], references: [id], onDelete: Cascade)
  batches     CalcBatch[] @relation("ScenarioBatches")

  @@index([tenantId])
  @@index([pamId])
  @@index([tenantId, name])
}

model ProviderCredential {
  id          String    @id @default(uuid())
  tenantId    String // FK to Team.id
  provider    String // "PLATTS", "OANDA", "ARGUS", etc.
  name        String // User-friendly name for this credential
  description String?   @db.Text

  // Encrypted credential data (using envelope encryption)
  encryptedData String  @db.Text // JSON blob of EncryptedEnvelope

  // Metadata
  createdBy     String // FK to User.id
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastUsedAt    DateTime? // Track when credential was last used
  lastRotatedAt DateTime? // Track last rotation
  expiresAt     DateTime? // Optional expiration date

  // Relations
  tenant Team @relation("ProviderCredentialTenant", fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, provider, name])
  @@index([tenantId])
  @@index([provider])
  @@index([tenantId, provider])
}
